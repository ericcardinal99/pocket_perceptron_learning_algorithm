# -*- coding: utf-8 -*-
"""PocketPerceptronAlgorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12LOKdiVH-SN2Q-BWmLSRD07tLimB3_cX
"""

# Starter code for implementing a pocket perceptron as a Scikit-Learn Estimator
# Reference: https://scikit-learn.org/stable/developers/develop.html
import numpy as np
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.utils.validation import check_X_y, check_array, check_is_fitted
from sklearn.utils.multiclass import unique_labels
from sklearn.metrics import euclidean_distances
class MyPocketPerceptron(BaseEstimator, ClassifierMixin):
    def __init__(self, max_iter=100):
        self.max_iter = max_iter
        self.w_ = []
    def fit(self, X, y):
        # Check that X and y have correct shape
        X, y = check_X_y(X, y)
        # Store the classes seen during fit
        self.classes_ = unique_labels(y)
        self.X_ = X
        self.y_ = y
        # Return the classifier
        self.w_ = self._perceptron_learning(X, y)
        return self
    def predict(self, X):
        # Check if fit has been called
        check_is_fitted(self)
        # Input validation
        X = check_array(X)
        y = []
        for x in X :
          result = MyPocketPerceptron._classify(x, self.w_)
          y.append(result)
        return y
    @staticmethod
    def _classify(x, w):
        y = np.dot(w, np.insert(x,0,1).transpose())
        target = 1.0 if (y > 0) else 0.0
        return target

    def _perceptron_learning(self, X, y):
        w = np.zeros(shape=(1, X.shape[1]+1))
        #
        # Perceptron Learning Implementation
        #
        t = 0
        best_t = 0
        best_differences = float("inf")

        while t <= self.max_iter:
          current_iteration_results = []

          for x in X:
            current_iteration_results.append(self._classify(x, w[t]))

          differences = y - current_iteration_results
          differences_count = len(differences) - (differences == 0).sum()

          if differences_count == 0:
            best_t = t
            break

          first_diff_index = np.where(differences != 0)[0][0]
          wt1 = []
          for i in range(len(w[t])):
            x = X[first_diff_index]
            wt1.append(w[t][i] + differences[first_diff_index]*np.insert(x,0,1)[i])

          w = np.vstack([w, wt1])

          if differences_count < best_differences:
            best_differences = differences_count
            best_t = t

          t += 1
        return w[best_t]

"""Driver code to use MyPocketPerceptron and test its performance."""

from google.colab import drive
import pandas as pd

SETOSA_URL_ = "/content/drive/My Drive/CMPE257-Shared/iris-setosa-labels.csv"
drive.mount('/content/drive',force_remount=True)
data = pd.read_csv(SETOSA_URL_, header = None)
print(data.shape)
print(data)

from sklearn.model_selection import train_test_split

setosa_data = data.drop(data.columns[4], axis=1)
print(setosa_data.shape)
print(setosa_data)

setosa_labels = data[data.columns[4]]
print(setosa_labels.shape)
print(setosa_labels)

train_data, test_data, train_labels, test_labels = train_test_split(setosa_data, setosa_labels, random_state=1)

print(train_data.shape)
print(train_labels.shape)

from sklearn.metrics import accuracy_score

perceptron = MyPocketPerceptron()
perceptron.fit(train_data, train_labels)


train_predicts = perceptron.predict(train_data)
train_score = accuracy_score(train_predicts, train_labels)
print("train accuracy: ", train_score)

test_predicts = perceptron.predict(test_data)
test_score = accuracy_score(test_predicts, test_labels)
print("test accuracy: ", test_score)